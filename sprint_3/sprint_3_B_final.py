# coding: utf-8
# Successful submition: 69806060

"""
-- ПРИНЦИП РАБОТЫ --
В соответствии с условием задачи необходимо оптимизировать
алгоритм быстрой сортировки (Quicksort) таким образом, чтобы
доп. память не использовалась, то есть входной массив не будет
явно делится на три новых массива - с элементами меньшими, равными
и большими, относительно опорного элемента (pivot).

Для этого применяется метод двух указателей - на левую и правую
границы сортируемого массива, а также указатель на опорный элемент.

В качестве опорного элемента будет выбираться середина текущего массива,
так как на мой взгляд это более интуитивно понятно, и позволяет отказаться
от использования доп. импортов, как в случае с выбором случайного элемента.

Следовательно, на каждом шаге выбирается опорный элемент, далее 
массив переупорядочивается так, чтобы сначала шли элементы, 
не превосходящие опорного, а затем —– большие опорного.

Затем сортировка вызывается рекурсивно для двух полученных частей. 

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Общий принцым алгоритма быстрой сортировки не изменяется, 
массив также делится на две части относительно опорного элемента,
а затем рекурсивно отрабатывает для этих двух частей.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Операция разделения массива на две части относительно опорного элемента занимает время O(n). 
Поскольку все операции разделения, проделываемые на одной глубине рекурсии, 
обрабатывают разные части исходного массива, 
размер которого постоянен, суммарно на каждом уровне рекурсии потребуется также O(n) операций. 
Следовательно, общая сложность алгоритма определяется лишь количеством разделений, то есть глубиной рекурсии. 
Глубина рекурсии, в свою очередь, зависит от сочетания входных данных и способа определения опорного элемента.

В самом худшем случае, когда два подмассива получаются с размерами 1 и n-1 соответственно,
то есть при каждом рекурсивном вызове массив будет лишь на 1 элемент короче, 
чем на предыдущем вызове, временная сложность составит n * n = O(n^2). Такое может произойти
в случае, если на каждом этапе разделения будет выбираться либо наибольший, либо наименьший элемент
в качестве опорного, либо когда на вход получаем уже отсортированный массив.

В среднем же быстрая сортировка отработает за О(n*log(n)) - при удачном разбиении массива
на две равные половины максимальная длина рекурсии составит log2n, в случаях неравного разбиения
 сложность алгоритма будет такой же, только с разными константами, например, в случае разделения 
 массива 25% / 75% глубина рекурсии составит log 4/3, что по-прежнему дает сложность O(n*logn).

 # https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0#%D0%9E%D1%86%D0%B5%D0%BD%D0%BA%D0%B0_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Дополнительная память не используется, поэтому
пространственная сложность = О(1).

"""

from typing import List, Any


class ScoreBoard:
    
    def __init__(self, name: str, score: int, penalty: int) -> None:
        self.name = name
        self.score = score
        self.penalty = penalty

    @property
    def key(self):
        return (-self.score, self.penalty, self.name)

    def __gt__(self, other) -> bool:
        return self.key > other.key

    def __lt__(self, other) -> bool:
        return self.key < other.key
    

def quick_sort(a: List[Any], left: int, right: int) -> None:
    if left >= right:
        return
    pivot_idx = (left + right) // 2
    pivot = a[pivot_idx]
    l, r = left, right
   
    while l <= r:
        while a[l] < pivot:
            l += 1
        while a[r] > pivot:
            r -= 1
        if l <= r:
            a[l], a[r] = a[r], a[l]
            l += 1
            r -= 1

    quick_sort(a, left, r)
    quick_sort(a, l, right)


if __name__ == "__main__":
    n = int(input())
    results = []
    for _ in range(n):
        name, score, penalty = input().strip().split()
        results.append(ScoreBoard(name, int(score), int(penalty)))
    quick_sort(results, 0, n-1)
    for res in results:
        print(res.name)
