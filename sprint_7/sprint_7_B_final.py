# coding: utf-8
# Successful submission: 73874582

"""
ПРИНЦИП РАБОТЫ
    Задача разбиения множества чисел на два подмножества таким образом, 
    чтобы сумма чисел двух подмножеств была равна является вариантом 
    задачи о рюкзаке. То есть нам нужно выяснить, можно ли из исходного
    множества выбрать такие элементы, которые в сумме давали бы определенный
    результат, то есть target.

    В данном случае целью будет являться половина суммы чисел исходного множества:
    если Sum({i0...in}) = S, тогда target = S / 2. Причем если сумма элементов мно-
    жества является нечетным числом, то разбиение невозможно.

ДОКАЗАТЕЛЬСТВО КОРРЕКТОСТИ
    Для решения задачи воспользуемся методом динамического
    программирования.
    
    Для хранения динамики потребуется массив размером target + 1, так как в 
    нулевом по индексу элементе массива будет хранится базовый случай.

    Базовым случаем динамики будет target == 0 при пустом множестве.
    Можем ли мы получить сумму = 0 при отсутсвии элементов? Да, можем.

    Переходом динамики будет поиск таких элементов множества, которые
    в сумме дадут target. Это может быть как отдельный элемент входного
    множества, так и их комбинация. То есть при рассмотрении очередного элемента num
    необходимо определить, является ли этот элемент == target, либо есть ли в массиве
    dp число, которое = target - num:

    dp[i] = dp[i] or dp[i - num]

    Ответ будет хранится на пересечении первых символов последовательностей, то есть в 
    ячейке c индексом target:
        
        nums = [1, 2, 4, 5]; S = 12, target = 6;
        
        idx:   0      1      2      3      4      5      6
        dp = [True, False, False, False, False, False, False]
      1 шаг  [True, True, False, False, False, False, False]
      # при num == 1 можно получить только 1 == True, либо
      # 0 + 1 = 1 == True

      итог: [True, True, True, True, True, True, True]
      # dp[target] == True, s1 = {1, 5}, s2 = {2, 4}


ВРЕМЕННАЯ СЛОЖНОСТЬ
    Необходимо итеративно заполнить массив длины target, при этом
    рассмотрев все элементы входного множества размера n элементов:
    O(n * m)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
    Для хранения результатов вычислений динамики нам понадобится массив,
    размером О(m), где m - полусумма входного множества.

"""

from typing import List

def points_partition(points: List[int]) -> bool:
    
    total = sum(points)
    if total % 2 != 0:
        return False
    target = total // 2

    dp = [True] + [False] * target
    for point in points:
        for j in range(target, point - 1, -1):
            dp[j] = dp[j] or dp[j - point]

    return dp[target]


if __name__ == "__main__":
    n = int(input())
    data: List[int] = list(map(int, input().split()))
    print(points_partition(data))
